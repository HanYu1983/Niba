// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package tool

import (
	"fmt"
	"math/rand"
	"time"
)

// ShuffleChess is
func ShuffleChess(arr []Chess) {
	t := time.Now()
	rand.Seed(int64(t.Nanosecond()))

	for i := len(arr) - 1; i > 0; i-- {
		j := rand.Intn(i)
		arr[i], arr[j] = arr[j], arr[i]
	}
}

// FilterChess is
func FilterChess(s1 []Chess, f func(Chess) bool) []Chess {
	ret := []Chess{}
	for _, v := range s1 {
		if f(v) {
			ret = append(ret, v)
		}
	}
	return ret
}

// RemoveChess is
func RemoveChess(s1 []Chess, card Chess) ([]Chess, error) {
	if len(s1) == 0 {
		return s1, nil
	}
	ret := []Chess{}
	for _, c := range s1 {
		if c == card {
			continue
		}
		ret = append(ret, c)
	}
	if len(s1) == len(ret) {
		return s1, fmt.Errorf("item not found")
	}
	return ret, nil
}

// ReplaceChess is
func ReplaceChess(items []Chess, info map[Chess]Chess) []Chess {
	ret := make([]Chess, len(items))
	copy(ret, items)
	for origin, next := range info {
		for idx, card := range items {
			if card == origin {
				ret[idx] = next
			}
		}
	}
	return ret
}

// ReplaceIndexChess is
func ReplaceIndexChess(items []Chess, info map[int]Chess) []Chess {
	ret := make([]Chess, len(items))
	copy(ret, items)
	for idx2, next := range info {
		for idx := range items {
			if idx == idx2 {
				ret[idx] = next
			}
		}
	}
	return ret
}

// AnyChess is
func AnyChess(items []Chess, f func(Chess) bool) bool {
	return len(FilterChess(items, f)) > 0
}
