// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package tool

import (
	"fmt"
	"math/rand"
	"time"
)

// ShuffleInt is
func ShuffleInt(arr []int) {
	t := time.Now()
	rand.Seed(int64(t.Nanosecond()))

	for i := len(arr) - 1; i > 0; i-- {
		j := rand.Intn(i)
		arr[i], arr[j] = arr[j], arr[i]
	}
}

// FilterInt is
func FilterInt(s1 []int, f func(int) bool) []int {
	ret := []int{}
	for _, v := range s1 {
		if f(v) {
			ret = append(ret, v)
		}
	}
	return ret
}

// RemoveInt is
func RemoveInt(s1 []int, card int) ([]int, error) {
	if len(s1) == 0 {
		return s1, nil
	}
	ret := []int{}
	for _, c := range s1 {
		if c == card {
			continue
		}
		ret = append(ret, c)
	}
	if len(s1) == len(ret) {
		return s1, fmt.Errorf("item not found")
	}
	return ret, nil
}

// ReplaceInt is
func ReplaceInt(items []int, info map[int]int) []int {
	ret := make([]int, len(items))
	copy(ret, items)
	for origin, next := range info {
		for idx, card := range items {
			if card == origin {
				ret[idx] = next
			}
		}
	}
	return ret
}

// FindIntIndex is
func FindIntIndex(items []int, target int) int {
	for idx, item := range items {
		if item == target {
			return idx
		}
	}
	return -1
}

// ReplaceIntIndex is
func ReplaceIntIndex(items []int, info map[int]int) []int {
	ret := make([]int, len(items))
	copy(ret, items)
	for idx2, next := range info {
		for idx := range items {
			if idx == idx2 {
				ret[idx] = next
			}
		}
	}
	return ret
}

// TryGetInt
func TryGetInt(items []int, i int) (int, error) {
	if i < 0 || i >= len(items) {
		ret := map[int]int{}
		return ret[0], fmt.Errorf("[TryGetInt]out of range (%v/%v)", i, len(items))
	}
	return items[i], nil
}

// TryGetInt2
func TryGetInt2(items [][]int, i int) func(j int, err error) (int, error) {
	return func(j int, err error) (int, error) {
		if err != nil {
			ret := map[int]int{}
			return ret[0], err
		}
		if i < 0 || i >= len(items) {
			ret := map[int]int{}
			return ret[0], fmt.Errorf("[TryGetInt2]out of range i (%v/%v)", i, len(items))
		}
		if j < 0 || j >= len(items[i]) {
			ret := map[int]int{}
			return ret[0], fmt.Errorf("[TryGetInt2]out of range j (%v/%v)", j, len(items[i]))
		}
		return items[i][j], nil
	}
}

// DifferenceInt
func DifferenceInt(a []int, b []int) []int {
	ret := []int{}
	for _, v := range a {
		has := false
		for _, v2 := range b {
			if v == v2 {
				has = true
				break
			}
		}
		if has == false {
			ret = append(ret, v)
		}
	}
	return ret
}

// IntersectionInt
func IntersectionInt(a []int, b []int) []int {
	ret := []int{}
	for _, v := range a {
		for _, v2 := range b {
			if v == v2 {
				ret = append(ret, v)
			}
		}
	}
	return ret
}

// ShuffleString is
func ShuffleString(arr []string) {
	t := time.Now()
	rand.Seed(int64(t.Nanosecond()))

	for i := len(arr) - 1; i > 0; i-- {
		j := rand.Intn(i)
		arr[i], arr[j] = arr[j], arr[i]
	}
}

// FilterString is
func FilterString(s1 []string, f func(string) bool) []string {
	ret := []string{}
	for _, v := range s1 {
		if f(v) {
			ret = append(ret, v)
		}
	}
	return ret
}

// RemoveString is
func RemoveString(s1 []string, card string) ([]string, error) {
	if len(s1) == 0 {
		return s1, nil
	}
	ret := []string{}
	for _, c := range s1 {
		if c == card {
			continue
		}
		ret = append(ret, c)
	}
	if len(s1) == len(ret) {
		return s1, fmt.Errorf("item not found")
	}
	return ret, nil
}

// ReplaceString is
func ReplaceString(items []string, info map[string]string) []string {
	ret := make([]string, len(items))
	copy(ret, items)
	for origin, next := range info {
		for idx, card := range items {
			if card == origin {
				ret[idx] = next
			}
		}
	}
	return ret
}

// FindStringIndex is
func FindStringIndex(items []string, target string) int {
	for idx, item := range items {
		if item == target {
			return idx
		}
	}
	return -1
}

// ReplaceStringIndex is
func ReplaceStringIndex(items []string, info map[int]string) []string {
	ret := make([]string, len(items))
	copy(ret, items)
	for idx2, next := range info {
		for idx := range items {
			if idx == idx2 {
				ret[idx] = next
			}
		}
	}
	return ret
}

// TryGetString
func TryGetString(items []string, i int) (string, error) {
	if i < 0 || i >= len(items) {
		ret := map[int]string{}
		return ret[0], fmt.Errorf("[TryGetString]out of range (%v/%v)", i, len(items))
	}
	return items[i], nil
}

// TryGetString2
func TryGetString2(items [][]string, i int) func(j int, err error) (string, error) {
	return func(j int, err error) (string, error) {
		if err != nil {
			ret := map[int]string{}
			return ret[0], err
		}
		if i < 0 || i >= len(items) {
			ret := map[int]string{}
			return ret[0], fmt.Errorf("[TryGetString2]out of range i (%v/%v)", i, len(items))
		}
		if j < 0 || j >= len(items[i]) {
			ret := map[int]string{}
			return ret[0], fmt.Errorf("[TryGetString2]out of range j (%v/%v)", j, len(items[i]))
		}
		return items[i][j], nil
	}
}

// DifferenceString
func DifferenceString(a []string, b []string) []string {
	ret := []string{}
	for _, v := range a {
		has := false
		for _, v2 := range b {
			if v == v2 {
				has = true
				break
			}
		}
		if has == false {
			ret = append(ret, v)
		}
	}
	return ret
}

// IntersectionString
func IntersectionString(a []string, b []string) []string {
	ret := []string{}
	for _, v := range a {
		for _, v2 := range b {
			if v == v2 {
				ret = append(ret, v)
			}
		}
	}
	return ret
}
